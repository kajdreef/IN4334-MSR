%!Tex root=../main.tex


\section{Related Work}
\label{sec:rel}

A number of prior studies focused on code ownership and its relationship with software quality. Bird et al.~\cite{bird:original} first examined this topic by defining ownership as a proportion of code contribution, and of minor and major contributors. Their results show that if a Microsoft Windows code artifact does not have a well-defined owner, then it is more likely to be defect prone, and the same holds if a lot of minor contributors have worked on it. 

Focault et al.~\cite{Foucault:oss} replicated the above study on seven open-source projects. They used the same granularity for the metrics and the same threshold to distinguish minor and major contributors while changing only the code artifacts on which the study was focused (Java files and packages). The outcome is contrasting with the previous results: it shows no strong correlation between ownership and defects, but it states that it is more significant when the metrics are computed on more coarse-grained artifacts. In contrast, Rahman et al.~\cite{Rahman:blame} confirmed Bird et al.'s findings by examining the concept at a finer granularity (line-level) and on open source software~\bray{check}. 


% A number of prior studies focused on code ownership and its relationship with software quality. 
% Bird et al.~\cite{bird:original} first examined this topic defining the concepts of ownership as proportion of contribution, and of minor and major contributors. These are the concepts that we use in this work, but with a different granularity and on different type of software artifacts. Their results show that if a Microsoft Windows code artifact does not have a well defined owner then it is more defect prone, and the same holds if a lot of minor contributors have worked on it. 

% Rahman et al.~\cite{Rahman:blame} examined the effects of ownership and authorship on software quality using a fine-grained approach and computing their metrics on chunks of implicated code. Our approach to determine software artifacts that contain implicated code is based on that work. They report findings similar to the ones reported by Bird et al. and described above. However, they consider ownership in a different way and use different metrics.

% Focault et al.~\cite{Foucault:oss} replicated the study Bird et. al~\cite{bird:original} on seven open-source projects, but using the same granularity for the metrics and the same threshold to distinguish minor and major contributors, and changing only the code artifacts on which the study was focused (Java files and packages). The outcome is contrasting with the previous results, it shows no strong correlation between ownership and defects, but it states that it is more significant when the metrics are computed on more coarse-grained artifacts.


% None of the studies that consider ownership as intended in this work~ \cite{bird:original, Foucault:oss, Greiler:replication} tried to compute it on artifacts that contain implicated code. Rahman et al.~\cite{Rahman:blame} computed authorship on implicated code, but considering only the implicated lines and not the whole file.

Another replication of the study from Bird et al. was recently performed by Greiler et al. \cite{Greiler:replication}, including also the intuition from Focault et al. of changing the granularity of the code artifacts: they used folders and files. This study was again targeted on Microsoft projects and confirms the result of \cite{bird:original}. They show that it is also possible to classify with a high precision defective files using the ownership metrics.

In this paper, we took a different approach; we investigated how risky a commit can be depending on its author's ownership. Thus, here we measure ownership-quality relationship at commit granularity, as opposed to release granularity like our predecessors. To build our model we adapted the concept of {\em implicated code} by Rahman et al.~\cite{Rahman:blame} (see Section~\ref{sec:method}). The concept of implicated code was also used in other bug prediction literature including Sliwersky et al.~\cite{sliwerski2005changes}, Purushothaman et al.~\cite{purushothaman2004towards}, Ray et al.~\cite{ray2015naturalness}, etc.
\bray{Review related work might have some relevance here.}
\bray{Blend this later.}
A number of prior studies also tried to use a different granularity to compute the ownership metrics or to perform bug prediction using line-based approaches: Munson et al.~\cite{munson1998code} introduced the concept of code churn as a measure of code line changes, Meng et al.~\cite{meng2013mining} considered fine-grained code changes over-time to measure the authorship in an accurate way and Hata et al. \cite{hata2012bug} computed ownership at a method level for bug prediction.

For what concerns the bug linking technique, D'Ambros et al.~\cite{d2012evaluating} described a method to identify bug-fixes using information from the JIRA and Bugzilla issue tracking systems: our technique is simpler but has more requirements (i.e. JIRA and the Apache convention, see Section~\ref{sec:bug-linking}).


% The concept of implicated code was used also by more previous works, for different purposes and with different names. Changes that introduce code that causes a fix are called fix-inducing by Sliwersky et al.~\cite{sliwerski2005changes} and dependencies by Purushothaman et al.~\cite{purushothaman2004towards}.

% A number of prior studies also tried to use a different granularity to compute the ownership metrics or to perform bug prediction using line-based approaches: Munson et al.~\cite{munson1998code} introduced the concept of code churn as a measure of code line changes, Meng et al.~\cite{meng2013mining} considered fine-grained code changes over-time to measure the authorship in an accurate way and Hata et al. \cite{hata2012bug} computed ownership at a method level for bug prediction.

% For what concerns the bug linking technique, D'Ambros et al.~\cite{d2012evaluating} described a method to identify bug-fixes using information from the JIRA and Bugzilla issue tracking systems: our technique is simpler but has more requirements (i.e. JIRA and the Apache convention, see Section~\ref{sec:bug-linking}).

